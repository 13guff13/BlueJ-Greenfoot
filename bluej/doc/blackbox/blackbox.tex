\documentclass{book}

\usepackage[margin=1.5in]{geometry}

\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue}

\usepackage{listings}
\lstMakeShortInline{|}
\lstset{columns=fixed,language=SQL,basicstyle=\ttfamily}

\newcommand{\myref}[1]{\autoref{#1} on page \pageref*{#1}}
\newcommand{\tabref}[1]{\lstinline|#1| table (see \myref{tab:#1})}

\newcommand{\intern}{When the server comes to add a record to this table with
  duplicate data to a previous record, it might reference the existing
  record instead, to save space.  This is a performance optimisation that should have
  no effect on the semantics.}

\begin{document}

This document acts as a manual for the BlueJ data collection project,
``Blackbox''.  It is intended to explain, in detail, the schema of the
collected data, and how the data relates to the BlueJ IDE.  It assumes a basic
familiarity with BlueJ's capabilities, such as the debugger, codepad, object
bench and so on.

\chapter{Concepts}

There are several concepts involved in the Blackbox project, and it is
very important when doing analysis on the data to understand the concepts
involved, and particularly the limitations of the data collection.  If you
naively assume that one virtual user is one real person, you may draw false
conclusions from your analysis.

\section{Users}

BlueJ stores its properties file in a per-user location.  For example, on
Linux, it uses |~/.bluej/bluej.properties|, on Windows 7 it is (on a typical
home installation) |C:\Users\Joe\bluej\bluej.properties|.

This properties file is the only mechanism that BlueJ has to have any sense of
identity.  If two physical people use the same account, they will appear to
BlueJ as a single user (this is still quite common on home Windows systems).
If someone uses BlueJ on a university machine, and on a laptop, and on a home
machine, they will appear to be three users.
If the computer is set up to not maintain a user's profile correctly (e.g. a
school system which wipes a user's profile on logout -- we know some systems
do this!), they will get a new profile each time they load BlueJ, and thus
will always appear to be a new user.  If the same bluej.properties file is
shared between many physical users (e.g. they all get the same profile on
login), they will all appear to be the same user (operating with many parallel sessions).

The user's unique identifier or opt-out preference is stored in this
properties file.  Thus the concept of a ``user'' is tied to the properties
file.  It is important to understand this when reasoning about users.

\section{Projects}

BlueJ deals with projects.  A project is a directory with a BlueJ project
file, and source files (and class files, and maybe a README, and whatever else
the user stores in the directory).  In Blackbox terms, projects are associated
with particular user ids.  They are identified only by the associated user,
and their full path (hashed, for anonymity).

If a user makes a copy of a project and opens it, it will appear to be an
entirely separate project (though you could post-process the data to see that
the project has the same source code as another of the user's projects).  If a
user has the project on a USB memory stick, and it gets assigned a different
drive letter next time they plug the stick in, the project will appear to be
different.  If a person loads the project from two different machines, even if
the project has the same path on both machines, they will appear as separate
projects belonging to separate users.

\section{Packages}

A project will have at least one package (the unnamed, default Java package),
and potentially many.  BlueJ displays a main interface window for each package
that the user opens within the project.  Thus there can be as many codepads as
there are packages in the project.  Some BlueJ features are per-package (codepad,
object bench), while others are per-project (debugger, version control).

\section{Sessions}
\label{def:sequence_id}

Each time that BlueJ is opened, we deem the time from the opening to the
closing to be ``a session''.  Each time BlueJ is loaded, the client generates
a unique session identifier to label all events from that session with.

If a user loads many projects at once in a single instance of BlueJ, these
will all count as one session.  If a user loads BlueJ twice in parallel
(e.g. by clicking the shortcut too many times), both sessions will be
recorded.  But for this reason, it is usually a good idea to use sessions to
process events, rather than solely relying on event timestamps (which will
interleave events from the two sessions).  If a user accidentally closes BlueJ
and immediately re-opens it, that will count as two sessions (though you could
spot this using the timestamps on the events in post-processing).

\section{Institutions}
\label{def:institution_id}

TODO

\section{Events}

The BlueJ client sends a stream of events to the BlueJ server, which
acknowledges them.  Ultimately, all the information recorded on the server
came by way of these discrete events.  Things like users or sessions are
reconstructed from the individual events that have been sent.  Every event
that the server receives, bar none, is recorded with an entry in the \tabref{master_events}.

\section{Interrupted Connections}
\label{def:interruption}

There are potential problems with missing events or entire sessions in the
event stream for a user.  You should
never assume you have a user's complete history of interaction with BlueJ.
Notably, entire sessions might be missing due to users using BlueJ without an
internet connection (e.g. on an aeroplane).  Similarly, you should not assume
that you can see all interactions with a project -- source code could be
edited outside BlueJ, but even within BlueJ sessions might be missing.

Within a session, you can assume that you have all events, sequentially
consistent, from the first \texttt{bluej\_start} event, up until the last
event that is recorded in the session.  This may not be the actual final event
that the user performed in their real session -- the user's
internet connection may drop, or BlueJ may crash or get killed before a batch of events
is sent, and so on.  But there will never be a ``hole'' in the middle of a
session where events are lost, then resumed again.  Any event that fails to
send will cause the BlueJ client to stop sending for the rest of the session
-- each event is only sent once the event before it in the session has succeeded.

\section{Spam}
\label{def:spam}

The BlueJ data collection project server is an open web server to which anyone
can submit, and the BlueJ client is an open-source program.  There is no
technical way to guarantee that the data coming in is from an unmodified BlueJ
client -- it could be modified, or it could simply be made-up spam data being
submitted.  It remains to be seen whether this will be an issue.

\section{Source Code Consistency}

TODO talk about edits being captured, but a project-open event may well be a
huge edit, if project has been modified elsewhere

\section{The Debug VM}

BlueJ has two virtual machines.  One, generally known as the server VM,
handles:

\begin{itemize}
\item The graphical interface
\item Code editing
\item Compilation
\end{itemize}

No user code is ever run on the server VM.  All user code is run on a second
VM, known as the client VM or the debug VM.  (There is only ever one debug VM
at a time, for each project.)  So things like:

\begin{itemize}
\item Object construction
\item Method invocations
\item Codepad use
\item JUnit tests
\end{itemize}

Are all run on the debug VM.  When the debugger is used, the interface and
control code are in the server VM, using hooks into the debug VM to do
stepping and so on.  Whenever user code is executed, it is possible that the
result is that the debug VM terminates, but this does not mean that BlueJ has
exited.  User code that runs forever will not interrupt BlueJ, but will
prevent further use of the debug VM.


\section{Extensions}

TODO say that extensions can trigger pretty much every event here, and it is
indistinguishable from user-triggered -- but you do at least get a list of
loaded extensions.

\chapter{Database Structure}
\label{sec:assoc}

The database is used as a persistence layer by our Ruby on Rails server, which
uses an object-store model.  Every table in the database, bar none, has an
integer |id| field which acts as a primary key.  Relations in the database are
handled in two ways:

\begin{enumerate}
\item When the destination table is fixed, e.g. a master event has a user,
  there is a field in the |master_events| table named |user_id| which links to
  the |users| table.
\item When the destination table may vary, e.g. a master event has a sub
  ``event'' record which may be from one of many tables, there is both an
  |event_id| and an |event_type| field.  The |event_type| field contains an
  uppercased camel-cased, non-underscored\footnote{This is Rails' doing -- don't ask.} version
  of the table name.  So if a particular master event links to a compile
  event, the |event_type| field will have |"CompileEvent"|, and the |event_id|
  will correspond to an |id| in the |compile_events| table.
\end{enumerate}

\chapter{Master Events}
%schema:master_events

The master events table is the place where all events are entered.  There are
lots of different types of events that can be received, each with a variety of
different data, but all of them get one entry in the |master_events|
table, with links to other tables where necessary.

The most important field in the table is the |name| field, which describes
which kind of event it is, and determines which of the other fields will be present.

Each master event has links (as per \myref{sec:assoc}) to other tables:
\begin{itemize}
\item |user_id| -- present for all events
\item |session_id| -- present for all events
\item |project_id| -- present for all events except |bluej_start| and |bluej_finish|
\item |package_id| -- present for some events (see further details below).
\item |event_id|, |event_type| -- present for some events (see further details below).
\item |institution_id| -- present for all events, if the user currently has an
  institution specified.
\item |client_address_id| -- present for all events.
\end{itemize}

The |created_at| field is a server-side, trustworthy datestamp of when
the event was received.  The |source_time| is the client-side time,
which is likely (but not guaranteed) to be sequentially consistent, but should
not be trusted to be accurate.

The |sequence_num| field is provided by the client to make sure events are
received in correct sequence (within a given session).  The server ensures
that the sequence numbers are valid (i.e. that they begin at 1, and each
subsequent event increments the sequence number by 1).

The subsequent sections describe the different values for the
|master_events.name| field, and what that means for the other fields,
especially what may be linked to by the |event_id| and |event_type| fields.

%hidden:institutions

The |institution_id| field links to a hidden |institutions| table.

%hidden:client_addresses

The |client_address_id| field links to a hidden |client_address| table.
However, you can assume that there is a one-to-one mapping between
|client_address_id| and IP addresses from which the event is sent.


\section{Start/Finish Events}

\subsection{\lstinline|bluej_start| and \lstinline|bluej_finish|}

These two events have no extra accompanying event.  They have no
|project_id| and no |package_id|.  However, the |bluej_start| event:

\begin{itemize}
\item will have an entry in the \tabref{installation_details} that links back to this
  master event, and
\item  will have zero or more attached entries in the \tabref{extensions} that link back to this master event
-- these are extensions loaded from
the system directories.
\end{itemize}

The |installation_details| table contains the BlueJ |interface_language| -- the
possible options are listed in the bluej.defs file.  The |operating_system|
field glues together (with slashes) the output of Java's |System.getProperty|
call for the keys |"os.name"|, |"os.arch"| and |"os.version"|.  The
|bluej_version| is the version of BlueJ they are running, and |java_version|
is the Java version being used to run BlueJ.

%schema:installation_details \intern

The |extensions| table contains the (self-reported) name and version of a
BlueJ extension.  BlueJ comes with the submitter extension installed by default.

%schema:extensions

\section{Project Events}

\subsection{\lstinline|project_opening|}

This event has no |package_id|.

This event will have zero or more entries in the \tabref{extensions}, which
represent extensions loaded from this project's directory.

\subsection{\lstinline|project_closing|}

This event will no attached data, and will have no |package_id|.


\section{Package Events}

\subsection{\lstinline|package_opening|}

This event will have a |package_id|.

The event will have zero or more entries in the \tabref{source_histories} that
link back to this event.  These represent the state of the files as the project is
opened (as a |complete| snapshot, not a diff).

The event will link to an entry in the |SourceHashes| table
(|event_type| will be |"SourceHash"|), which will contain a hash of
the source code in the package.  The exact details of the hash are
unimportant, but this hash can be used to quickly narrow down likely
duplicate projects (for example, spotting the starting projects from
the BlueJ book).

%schema:source_hashes

\subsection{\lstinline|package_closing|}

This event will have a |package_id|, but no other associated data.


\section{Editing}

\subsection{\lstinline|edit|}

This event is the central editing event in BlueJ.  These events are recorded
when multiple lines are edited at once (e.g. via paste, or deleting a
selection, or so on), or a single line has been edited and the caret
has now left that edited line.  An edit event is not generated by every single
keystroke.

There is currently no guarantee as to how edits are grouped together into a single edit
event (e.g. highlighting a selection and then pasting may appear as one event
or two events, auto-indent may appear as one edit or several edits, and many
other such examples), but an edit event will never span a compiler event, and
all edits will be flushed before a compile event.

The event will always have exactly one associated entry in the
\tabref{source_histories}, which will be a |diff| event.

\subsection{\lstinline|file_add|}

This event will have a |package_id|, which indicates which package the file
was added to.

This event is fired whenever a class is added to the BlueJ project.  This may
be via the New Class menu item, or via the Import Class menu item, or via
version control.

The event will always have exactly one associated entry in the
\tabref{source_histories}, which will be a |complete| event.

\subsection{\lstinline|file_delete|}

This event will have a |package_id|, which indicates which package the file
was deleted from.

This event is fired whenever a class is removed from a BlueJ project.  This
may be via the interface, or via version control.

The event will always have exactly one associated entry in the
\tabref{source_histories}, which will be a |file_delete| event.

\subsection{\lstinline|rename|}

This event will have a |package_id|, which indicates which package the file
was renamed in.

This event is fired whenever a class is renamed in a BlueJ project.  A rename
occurs in BlueJ when a Java file is saved, and is parseable, and has a
different top-level class name to the name of the file.  At this point, BlueJ
silently renames the file to match the class name.  But note that until this
save occurs, many more edits may take place, so the rename of the file may
appear some time after the actual relevant source code edit takes place.

The event will always have exactly one associated entry in the
\tabref{source_histories}, which will be a |rename| event.

\section{Compilation}

\subsection{\lstinline|compile|}

This event will have a |package_id| if and only if all the compiled files were
in the same package.  However, having a |package_id| does not necessarily
indicate that the user asked for the whole package to be compiled.

This event occurs whenever a compilation of the user's classes is triggered.
(This does not include things like codepad interactions).

This master event will always have |event_type| set to |"CompileEvent"|, and
|event_id| will reference an entry in the \tabref{compile_events}.  (In turn,
that entry in the |compile_events| table, will be linked to by one or more
|compile_inputs| and zero or more |compile_outputs|, but see the
\tabref{compile_events} for more details.)

\subsection{Related Tables}

The |compile_events| table records whether the compilation was a success
(i.e. no errors -- but there could be warnings) or not.

%schema:compile_events

The |compile_events| may then linked to by entries in the |compile_inputs| and
|compile_outputs| table.

The |compile_inputs| table is really just a link table, linking one compile
event to many source files.

%schema:compile_inputs

The |compile_outputs| table has an entry for each warning and each error that
occurred.  Note that these warnings and errors are reported from the standard Java
compiler from the JDK.  However, BlueJ may alter the format of some messages,
and will only display at most one error, and may ignore some warnings.  The
message recorded here is the altered format, and the |shown| flag indicates
whether or not this error or warning was actually displayed to the user.  The
|is_error| flag indicates if it was an error (otherwise it was a warning), the
|message| field shows the text that would be displayed to the user, and the
line and column fields indicate the error's location, as reported by the
compiler  (lines and columns begin at 1, not 0).

%schema:compile_outputs

\section{Miscellaneous Events}

\subsection{\lstinline|resetting_vm|}

This event has no |package_id|, because the debug VM is per-project.

The event occurs when the VM is restarted due to an explicit user request (via
a menu).  Although it has the same effect as the |debugger_terminate| event,
it is recorded separately.

\subsection{\lstinline|terminal_open| and \lstinline|terminal_close|}

These events have no |package_id|, because there is only one terminal
per project.

These events occur when the terminal window is shown or closed.  It
may be shown either due to explicit triggered by the user (via a menu
item) or because output has been generated by the debug VM (which
causes the terminal to be shown if it is not already shown).

\section{Debugger Events}

Some, but not all, debugger events link to the |debugger_events|
table, which can store thread names.

%schema:debugger_events

Other debugger events will link to the |breakpoints| table, which references a
source file and a line number (line numbers begin at 1, not 0).

%schema:breakpoints \intern

\subsection{\lstinline|debugger_open| and \lstinline|debugger_close|}

These events have no |package_id| (because the debugger is per-project).

These events occur when the debugger window is opened or closed.  The debugger
may open because the user explicitly opened the debugger (via the menu), or
because the code has hit a breakpoint.  No further data is attached.

\subsection{\lstinline|debugger_terminate|}

This event has no |package_id| (because the debugger is per-project).

This event occurs when the user clicks the Terminate button in the debugger.
It kills the current debug VM (which will be subsequently restarted, but will
be idle), and thus all currently-executing user code.  No
further data is attached.

\subsection{\lstinline|debugger_continue|}

This event has no |package_id| (because the debugger is per-project).

This event occurs when the user clicks the Continue button in the debugger on
a thread which is currently not executing.
It makes the selected thread resume execution.  

The |event_type| field will always be |DebuggerEvent|, and the |event_id| will
reference an entry in the \tabref{debugger_events}.  The |debugger_events|
entry will have the |thread_name| filled in, but there will be no further information.

\subsection{\lstinline|debugger_hit_breakpoint|, \lstinline|debugger_stepinto|, \lstinline|debugger_stepover| and \lstinline|debugger_halt|}

These events have no |package_id| (because the debugger is per-project).

These events occur when the user code in a thread becomes suspended.  The
|debugger_hit_breakpoint| event indicates that the suspension was due to
hitting a breakpoint, while |debugger_stepinto| and |debugger_stepover|
indicate that the thread has just completed a step request.  (If a step
request ends on a breakpoint, only the breakpoint is reported.)  The
|debugger_halt| is reported in the remaining case, that the user has
clicked the Halt button in the debugger (which pauses execution of the thread).

For these events, the |event_type| field will be always be |DebuggerEvent|,
and the |event_id| will reference an entry in the \tabref{debugger_events},
which will have the |thread_name| filled in.

There will also be one or more entries in the \tabref{stack_entries} which
will link to the |debugger_event| (not the master event) via the
|stack_entries.sub_event_type| and |stack_entries.sub_event_id| fields.

\subsection{\lstinline|debugger_breakpoint_add| and \lstinline|debugger_breakpoint_remove|}

These events do have a |package_id|, which indicates the package that the
involved source file is in.

These events occur when a user adds/removes a breakpoint.  The |event_type|
field will be |"Breakpoint"| and the |event_id| will reference an entry in
the \tabref{breakpoints}, which details the location of the breakpoint.


\section{Codepad}

\subsection{\lstinline|codepad|}

These events have a |package_id|, which indicates which package window the
codepad being used corresponds to (more by accident than by design, each
package window has its own codepad).

These events occur each time that the user types something into the codepad
window, presses return and gets a response.  The codepad event links to an item in the |codepad_events| table (the
|event_type| will be |"CodepadEvent"|, and the |event_id| will reference an
entry in the |codepad_events| table).

%schema:codepad_events

The |outcome| field indicates what happened when the code was
executed.  An |outcome| of |"success"| indicates that the code
successfully compiled, and executed without throwing an exception or without
exiting the VM early.  In this case, the fields |command| and |result|
will be filled in with the input and output respectively.


The |outcome| field being |"error"| indicates a compiler error occurred, or that the VM
exited during execution: the |command| and |error| fields will be filled in with the
input and error respectively.  The |outcome| field being |"exception"|
indicates an exception occurred: the |command| and |exception| fields
will be filled in with the input and exception respectively.


\section{Method Invocation}

Method invocations reference the |invocations| table.

%schema:invocations

\subsection{\lstinline|invoke_method|}

This event has a |package_id| field, which indicates which package window the
method was invoked from.  The method invoked is not guaranteed to be in this
package, as the user may have used the call-library-class function to invoke a
method on String, or any other class.

This event occurs when the user interactively (i.e. via a menu) invokes a
static method on a class or an instance method on an object on the object
bench, or uses the call-library-class menu function.  The |event_type| will
always be |Invocation| and the |event_id| will reference an entry in the
|invocations| table.  

In the |invocations| table, the |code| field will have the code that was generated
to execute the invocation.  The |result| field will have the result, which will be one of:

\begin{itemize}
\item |"success"| -- method was invoked successfully, the |bench_object_id|
  field will link to the |bench_objects| entry (if the result was added to the
  object bench, i.e. if the method was a constructor) and the the |type_name|
  field will have the type of the result.
\item |"compile_error"| -- an error occurred while compiling the generated code
  (e.g. because the user entered invalid parameters), the |compile_error|
  field will have the full message.
\item |"terminated"| -- the VM terminated during execution, e.g. due to a
  |System.exit| call.
\item |"exception"| -- an uncaught exception occurred during execution.  The
  |exception_class| field will have the class of the exception, the
  |exception_message| field will have the message, and there will be
  associated entries in the |stack_entries| table linking to this event (the
  |invocations| entry, not the |master_events| entry).
\end{itemize}

\section{Inspector}

The inspector events reference the inspectors table.

%schema:inspectors

\subsection{\lstinline|inspector_show| and \lstinline|inspector_hide|}

This event has a |package_id| field, which indicates which package window the
inspection was invoked from.  This is transitive, for occasions where users
inspect an object in an inspector.

Both of these events link to an entry in the |inspectors| table: the
|event_type| field will be |"Inspector"|, and the |event_id| field will be a
reference to an entry in the |inspectors| table.

For the |inspector_show| event, there are two cases:

\begin{enumerate}
\item The inspection was on a class.  In this case, the |static_class| field
  will have the name of the class, and the other fields will be empty.
\item The inspection was on an object.  In this case, the |class_name| field
  indicates the type of the object, the |display_name| (whatever is displayed
  on the left-hand side of the title in the object inspector) will be present,
  and the |bench_object_id| will link to a |bench_object| if the inspected
  object is on the object bench (regardless of whether that was how this
  object was reached for inspection).
\end{enumerate}

In both cases, the |unique| will have some string that uniquely identifies an
inspector within the session (this is useful during collection, and is of no
use afterwards, because the record will be unique per inspector).

For the |inspector_hide| event, there will be a link back to the |inspectors|
entry that was hidden.

\section{Object Bench}

\section{Testing}

\subsection{\lstinline|assertion|}

This event has a |package_id|, linking to which package the test was
recorded for.

The event links to an entry in the |assertions| table.

%schema:assertions

The |assertions| table links to an entry in the |invocations| table that the assertion
relates to, and to an entry in the |tests| table for the test which
this assertion will be recorded into.

The |assertion| field is the JUnit function that will be recorded,
e.g. |"assertEquals"|.  The |param1| field and |param2| fields are
the other parameters to the assertion.

\section{Version Control}

%schema:version_control_events

%schema:version_control_files

Each version control event has an associated entry in the
|version_control_events| table, with a |vcs_type| (built-in options:
|"CVS"|, |"SVN"|) and a |protocol| (e.g. |"http"| or |"svn+ssh"|).

\subsection{\lstinline|vcs_history| and \lstinline|vcs_share|}

These events get an associated entry in the |version_control_events|
table, but no more data than that.

\subsection{\lstinline|vcs_commit| and \lstinline|vcs_update|}

These events get an associated entry in the |version_control_events|
table, and also zero or more entries in the |version_control_files|
table, with just the |file| field filled in.

\subsection{\lstinline|vcs_status|}

This event gets an associated entry in the |version_control_events|
table, and also zero or more entries in the |version_control_files|
table, with the |file| field filled in, and the |status| field filled
in.

\chapter{Other Database Tables}

There are many database tables in the Blackbox schema.  These tables are
written to using an object framework (Ruby on Rails) with its own persistence
model.  Thus, each table has an \verb$id$ integer field which is the primary
key, even if it would make sense for a different field to be primary key.  The
\texttt{id} field is used internally for associations, but is assigned
server-side, and never bears any relation to the BlueJ client.

\section{Users}

%schema:users

The \texttt{uuid} field is the unique user identifier.  Whenever the BlueJ
client loads up and does not find a valid BlueJ profile file with an existing
UUID inside it, it generates a new UUID.  This means:

\begin{itemize}
\item if the user does not retain their profile file (e.g. their university
  does not have roaming profiles, or wipes profiles on logout), they will
  appear with a new UUID each time they load BlueJ.
\item if the same person uses BlueJ from home (or laptop, etc) and from
  university, they will appear as two separate users.
\item if two people share the same profile (e.g. a single-user home system),
  they will appear as one user.
\end{itemize}

The \texttt{created\_at} field shows the time that this user record was
created (the first time their UUID was seen), and the \texttt{last\_update} field shows the last time that data was entered for
this user.

The \texttt{last\_sequence\_id} field is the last \hyperref[def:sequence_id]{sequence identifier} seen for
this user, and similarly the \texttt{last\_institution\_id} is the last
\hyperref[def:institution_id]{institution identifier} seen for this user.

TODO make sure this is up-to-date

\section{Sessions}

%schema:sessions

Each session is associated with a specific user.  There is a link to
the \tabref{installation_details} -- specifically, the entry that
accompanied the |bluej_start| event that began this session.  The
|identifier| and |last_sequence_id| fields are used for internal
book-keeping, and can be ignored.  The |institution_id| field is set
to the last institution seen during the session.

\section{Projects}

%schema:projects

Each project is associated with a specific user.  A project is stored with the
md5 hash of its full path (|path_hash|), to try to identify the project across multiple
sessions.  For anonymity purposes, the full path is not sent to the server
(because it will typically have the user-name in the path), but the directory
name of the project (|name|) is sent, as this may be informative.

\section{Packages}

%schema:packages

Each package belongs to a specific project.  A package is identified by its
fully-qualified package name.  The default, unnamed package will have the
empty string as its name.

\section{Source Files}

%schema:source_files

Each entry in the |source_files| table corresponds to a particular
source path in a project.  (That is, if you delete a source file and
generate a new file with the same name, it may share the entry of the
original file.)

Each source file will have its path relative to the base of the
project.  So files that are within packages will have a path with the
parent package names as directories (which may use forward slash or
backslash for separation).

\section{Source Histories}

%schema:source_histories

Each entry in the |source_histories| table belongs to a particular
|master_event|, and is associated with a given |source_file|.  Based on the
|source_history_type| field, there can be different meanings to the |content| field:

\begin{itemize}
\item |source_history_type| is |"complete"| -- |content| has the complete text
  of the source file (anonymised).  This will be
  used by file additions, and source histories added on loading a package.
\item |source_history_type| is |"diff"| -- |content| has the diff (in unified diff format) from
  the previous version of the file.
\item |source_history_type| is |"rename"| -- |content| holds the name of the file before the rename.  During the
  rename, the source history will be updated to feature the new name of the
  file.
\item |source_history_type| is |"file_delete"| -- |content| will be blank.
\end{itemize}

\section{Stack Entries}

%schema:stack_entries

Any time that an event is associated with a stack trace, it will have
zero or more entries in this table: one for each line in the stack
trace.  (Some stack traces may be filtered by BlueJ -- the recorded
trace will always be the filtered version, i.e. the version that the
user actually sees.)

The |entry| field will be the index within the stack trace.  The top
line (typically, the actual location of the thrown exception, or
breakpoint, etc) of the trace will have |entry| of zero, with an
increasing |entry| index for each subsequent line.

The |class_source_name| field will be the name of the file involved,
and |line_number| will be the line number (line numbers start at 1).
So if an exception is thrown in an anonymous inner class of class Foo,
this field will be |"Foo.java"| -- even if Foo is inside a package.
The source name loses all package information, but this can be
recovered via the |class_name| field, which is the fully qualified
name of the class at the specific source location.

The |sub_event_id| and |sub_event_type| fields are what is used to
link the stack entries to their parent event -- see documentation
throughout the manual for events that have associated stack traces.
\section{Bench Objects}

%schema:bench_objects

Objects on the BlueJ object bench get an entry in the |bench_objects|
table.  The |name| field is the name/label of the object, and
|class_name| is the type of the object.  The |package_id| field links
to the package which is associated with the object bench that this
object is on.  The |session_id| field links to the session during
which this object existed.

The |test_id| field links to an entry in the \tabref{tests} -- this
link is present if (and only if) the given test was being recorded
when this object was added to the bench.

\section{Version Control}



\chapter{TODO List}

\section{Answers}

\begin{itemize}
\item Should we record events when they are triggered by extensions?
  (e.g. restart VM) -- DECIDED no, very invasive, not always possible
\item Should we model a session in the database? -- YES!
\item Should we record full stack trace during debugger, not just top line? -- YES
\item Do we want to record any Terminal usage? -- YES: open, close
\item Could we do better with distinguishing different projects with same
  name, e.g. hashing the path -- YES
\item Should we hard-code submit URL, or put it in properties?  Don't want to
  allow redirection too easily. -- hardcode, like stats
\item After removing old tables, change the |source_file| table to be
  |source_file_path| (or similar), remove the project link, and use it like
  |client_address| (i.e. a giant interned table for strings).  Although, is it
  being relied upon as a uniqueness measure by some things (e.g. renames)? --
  NO, I'm not sure this would save much anyway.
\item Put a version number in source histories, to ease putting the diffs back
  together -- NO, |id| will be sufficient for ordering, I think.  
\item Should we make everything link to master event where possible, not the
  sub-events? -- NO, if anything, probably the opposite
\end{itemize}

\section{Tasks}

\begin{itemize}
\item Check that the UUID is generated properly for new profiles, or profile without
UUID (or invalid UUID), and is separate to phone-home UUID
\item Finish opt-in dialog, and allow later opt-in/opt-out via prefs.
\item Implement institution ID, and changing thereof in the prefs.
\item Handle READMEs and classes without source code (e.g. in invoker?)
\item Make an md5sum of source code state on server, to help easily spot book projects
\end{itemize}

Testing/deployment:

\begin{itemize}
\item Check that all source file names are sent correctly (and are not class
  names -- or at least, make sure distinction is clear)
\item Make sure multi-threading is properly supported in the debugger
\item Make sure AJAX live stream is off in production!
\item Check speed (especially loading up)
\item Add views for white, remove visibility of ip and institution?
\item Are edits actually flushed before compilation?
\item Put in the actual URL for data submission (and set up black.bluej.org,
  or whatever)
\end{itemize}

\section{Questions}

Old:
\begin{itemize}
\item Added sessions, think they should become per-project, and maybe even per-package?
\item Should there be |project_opening| and |package_opening| events
  (basically, what about packages?)
\item What do we want from object bench and methods?  E.g. parameter values,
  return values, ``Get'' operations, Inspects
\item What do we record for JUnit -- generated code?
\item Do we want to record settings, e.g. whether scope highlighting is in
  use
\end{itemize}

New:
\begin{itemize}
\item Spurious |edit| at end of file on first load, I think it is adding final
  line break on load-up.  Is it worth trying to suppress this?
\item Add new package, remove package actions?
\item Should we mark auto-indent, add method, or find/replace separately to other edit events?
\end{itemize}

\end{document}
