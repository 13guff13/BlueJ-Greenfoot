\documentclass{book}

\usepackage{hyperref}
\usepackage{listings}

\lstMakeShortInline{|}

\begin{document}

\chapter{User Interactions}


\section{Debugger}

BlueJ has a built-in debugger with support for multiple threads, and the usual
interactions: continue/stop, step into/over, and terminate.

\chapter{Concepts}

\section{The Debug VM}

\section{Users}

\section{Projects}

Projects are associated with particular user ids.  They are identified only by
their name.  For anonymisation purposes, the name is only the name of the
project directory itself (e.g. ``assignment-1'') and not the full path.  This
means that two projects (belonging to the same user) in different locations with the same name will appear
to be the same.

When projects are opened, a \texttt{project\_opening} event is sent
(containing all the source code information), and when
a project is closed, a corresponding data-less \texttt{project\_opening} event
is sent.

\section{Sessions}
\label{def:sequence_id}

When BlueJ is first loaded, a \texttt{bluej\_start} event is sent to the
server.  It contains no real event-specific data, but marks the beginning of a
BlueJ session for that user.

When BlueJ is closed, a \texttt{bluej\_finish} event is sent to the server.
However, since this event is sent during closing, if it is delayed then BlueJ
will close anyway, so we cannot guarantee that every start event will have a
finish event (and besides, the connection might already have been interrupted
-- see \hyperref[def:interruption]{the section on interruption}.

The definitive way to spot sessions is to look at the sequence numbers on
events -- a session ends when the next event sets the number back to zero.

\section{Institutions}
\label{def:institution_id}

\section{Events}

The BlueJ client sends a stream of events to the BlueJ server, which
acknowledges them.  So each piece of data will be an event, with other
information attached.  Each event has an entry in the \hyperref[tab:master_events]{\texttt{master\_events}}

\section{Interrupted Connections}
\label{def:interruption}

There are potential problems with missing events or entire sessions in the stream.  You should
never assume you have a user's complete history of interaction with BlueJ.
Notably, entire sessions might be missing due to users using BlueJ without an
internet connection (e.g. on an aeroplane).  Similarly, you should not assume
that you can see all interactions with a project -- source code could be
edited outside BlueJ, but even within BlueJ sessions might be missing.

Within a session, you can assume that you have all BlueJ events, sequentially
consistent, from the first \texttt{bluej\_start} event, up until the last
event that is recorded in the session.  This may not be the final event -- the user's
internet connection may drop, or BlueJ may crash or get killed before a batch of events
is sent, and so on.  But there will never be a ``hole'' in the middle of a
session where events are lost, then resumed again.  Any event that fails to
send will cause the BlueJ client to stop sending for the rest of the session.

\section{Spam}
\label{def:spam}

The BlueJ data collection project server is an open web server to which anyone
can submit.  There is no technical way to \textit{a priori} guarantee that the
data coming in is from an unmodified BlueJ client -- it could be modified, or
it could simply be made-up spam data being submitted.

\section{Source Code Consistency}

TODO talk about edits being captured, but a project-open event may well be a
huge edit, if project has been modified elsewhere

\chapter{Database Tables}

There are many database tables in the Blackbox schema.  These tables are
written to using an object framework (Ruby on Rails) with its own persistence
model.  Thus, each table has an \verb$id$ integer field which is the primary
key, even if it would make sense for a different field to be primary key.  The
\texttt{id} field is used internally for associations, but is assigned
server-side, and never bears any relation to the BlueJ client.

\section{Users}

The \texttt{uuid} field is the unique user identifier.  Whenever the BlueJ
client loads up and does not find a valid BlueJ profile file with an existing
UUID inside it, it generates a new UUID.  This means:

\begin{itemize}
\item if the user does not retain their profile file (e.g. their university
  does not have roaming profiles, or wipes profiles on logout), they will
  appear with a new UUID each time they load BlueJ.
\item if the same person uses BlueJ from home (or laptop, etc) and from
  university, they will appear as two separate users.
\item if two people share the same profile (e.g. a single-user home system),
  they will appear as one user.
\end{itemize}

The \texttt{created\_at} field shows the time that this user record was
created (the first time their UUID was seen), and the \texttt{last\_update} field shows the last time that data was entered for
this user.

The \texttt{last\_sequence\_id} field is the last \hyperref[def:sequence_id]{sequence identifier} seen for
this user, and similarly the \texttt{last\_institution\_id} is the last
\hyperref[def:institution_id]{institution identifier} seen for this user.

\section{Master Events}
\label{tab:master_events}

The master events table is the place where all events are entered.  There are
lots of different types of events that can be received, each with a variety of
different data, but all of them get one entry in the \texttt{master\_event}
table, with links to other tables where necessary.

Each master event has a user ID and almost all have a project ID (the two
exceptions being \texttt{bluej\_start} and \texttt{bluej\_finish} events) -- the
\texttt{user\_id} and \texttt{project\_id} are foreign keys for the
\texttt{users} and \texttt{projects} tables respectively.  Similarly, if
present, the \texttt{institution\_id} field is a foregin key for the
\texttt{insitutions} table.

The \texttt{created\_at} field is a server-side, trustworthy datestamp of when
the event was received.  The \texttt{source\_time} is the client-side time,
which is likely (but not guaranteed) to be sequentially consistent, but should
not be trusted to be accurate.

The \texttt{event\_id} and \texttt{event\_type} fields describe a link to
another table.  The \texttt{event\_type} field will be a capitalised
camel-cased singular version of the table name, and the \texttt{event\_id} field will
be a foreign key in that table.  So, for example, if \texttt{event\_type} is
\texttt{"CompileEvent"}, then \texttt{event\_id} will match the appropriate
\texttt{id} in the \texttt{compile\_events} table\footnote{This is how Ruby on
  Rails stores polymorphic association, it's a little quirky but not too
  horrific.}.

The \texttt{event\_name} column stores the name of the event -- each event is
detailed in the following subsections.

All events will have a \texttt{user\_id}, an \texttt{event\_name}, a
\texttt{created\_at}, a \texttt{source\_time},
and an optional
\texttt{institution\_id}.  Unless specified otherwise, they will also have a \texttt{project\_id}.

\subsection{\texttt{bluej\_start} and \texttt{bluej\_finish}}

These two events have no extra accompanying data.  They have no
\texttt{project\_id}, and no other data.

\subsection{\texttt{project\_opening}}

This event will update the list of source files contained in a project, by
adding to the \texttt{source\_files} table.  This data is not stored with the
event (because it is a subset of the source histories).

The event will have an attached \hyperref[tab:source_histories]{collection of
  source histories}, representing the state of the files as the project is
opened (as a complete snapshot, not any kind of diff).

\subsection{\texttt{project\_closing}}

This event will no attached data (though it will have a \texttt{project\_id}).

\subsection{\texttt{resetting\_vm}}

This event will no attached data (though it will have a
\texttt{project\_id}).  It occurs when the VM is resetting, triggered either
by an explicit user request, or by a BlueJ extension.

\subsection{\texttt{compile}}

This event will link to an entry in the \texttt{compile\_events} table, which
in turn will be linked to by many entries in the \texttt{compile\_outputs}
table.  It occurs every time user source code is compiled.

\subsection{\texttt{multi\_line\_edit}}

This event is the central editing event in BlueJ.  These events are recorded
when multiple lines are edited, or a single line has been edited but the caret
has now left that line.  There is no guarantee as to how edits are grouped
together into a single edit event, but an edit event will never span a
compiler event (i.e. all edits will be flushed before a compiler).

A multi line edit will have exactly associated entry in the
\texttt{source\_histories} table.

\subsection{\lstinline|debugger_open| and \lstinline|debugger_close|}

These events occur when the debugger window is opened or closed.  No further
data is attached.

\subsection{\lstinline|debugger_terminate|}

This event occurs when the user clicks the Terminate button in the debugger.
It kills the current debug VM, and thus all currently-executing user code.  No
further data is attached.

\subsection{\lstinline|debugger_continue|}

This event occurs when the user clicks the Continue button in the debugger.
It makes the selected thread continue execution (until Halt is clicked, or a
breakpoint is hit).  An accompanying entry in the |debugger_events| table will
have the |thread_name|, but no source location.

\subsection{\lstinline|debugger_hit_breakpoint|,
  \lstinline|debugger_stepinto|, \lstinline|debugger_stepover| and
  \lstinline|debugger_halt|}

These events occur when the user code in a thread becomes suspended.  The
|debugger_hit_breakpoint| event indicates that the suspension was due to
hitting a breakpoint, while |debugger_stepinto| and |debugger_stepover|
indicate that the thread has just completed a step request.  (If a step
request ends on a breakpoint, only the breakpoint is reported.)  The
|debugger_halt| is reported in the remaining case, that the user has
clicked the Halt button in the debugger.

For |debugger_hit_breakpoint|, there will be a link to the |breakpoints|
table, which will specify a source file and a line number.  For breakpoints,
it is guaranteed that the source file will be within the project.

For the other events, the location where the execution may have halted could
be in user code, but it could also be in external code, such as user
libraries, or system libraries.  For the other three events, the link is to
the |debugger_events| table, with a |thread_name| and a |class_source_name|
and |line_number|.  Checking the class source against local source files must
be done in a post-processing step.

\subsection{\lstinline|debugger_breakpoint_add| and
  \lstinline|debugger_breakpoint_remove|}

These events occur when a user adds/removes a breakpoint.  They have a link to
the |breakpoints| table which details the location of the breakpoint.

\chapter{TODO List}

\section{Tasks}

\begin{itemize}
\item Check that the UUID is generated properly for new profiles, or profile without
UUID (or invalid UUID)
\item Create opt-in dialog, and allow later change
\item Let extensions find out UUID
\item Implement institution ID
\item Pause for a second or so to wait for BlueJ closing event to have good
  chance of succeeding
\item FIX THE DOUBLE-USE OF EVENT\_TYPE IN THE MASTER\_EVENTS TABLE!  It's
  currently used to store the underscore name with no link, but is re-used by
  rails to store capitalised version in the case where there is an event\_id.
  Add a new field for event\_name to store underscore version!
\item Have flag saying whether error was shown to user
\item Make sure file contents are anonymised, for complete and for diffs
\item Post-process this file to automatically inject schema contents
\item Change hyperrefs to have section number displayed (for paper printing)
  -- make new macro?
\item Should we rename multi-line edit and do away with [single] line edit?
\item Are edits actually flushed before compilation?
\item Each event should record which BlueJ version it was recorded with.
  Also, we should probably record OS (in the BlueJ start event?).
\item Refactor server to have one table for source locations (and have
  |debugger_breakpoint_add| and |debugger_breakpoint_remove| events)
\item Check that all source file names are sent correctly (and are not class
  names -- breakpoints are almost certainly wrong)
\item Make sure multi-threading is properly supported in the debugger
\item How long should we give the BlueJ-closing event to send before we force a
quit?
\end{itemize}

\section{Questions}

\begin{itemize}
\item Could we do better with distinguishing different projects with same
  name, e.g. hashing the path
\item Should we model a session in the database?
\item Do/should we record which extensions are loaded?
\item What is the relation (if any) between compile event and codepad use?
  Doesn't look like server supports code pad use (yet?)
\item We don't seem to record object construction at the moment -- should this be a
  special case of the method invocation event, or something separate?
  Probably need to record resulting object name.
\item Should we record events when they are triggered by extensions?
  (e.g. restart VM) -- DECIDED no, very invasive, not always possible
\item Should we record full stack trace during debugger, not just top line?
\item Do we need sequence numbers from client?  Just record on server?
\item Is it worth trying to coalesce identical records (e.g. source locations)
  -- speed vs space-and-simplicity?
\item Should we check halt/step locations against local source files
  ourselves, or leave it to post-processing?
\item Should there be project_opening and package_opening -- they are potentially
different?
\end{itemize}




\end{document}
