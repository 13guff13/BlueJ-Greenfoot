\documentclass{book}

\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue}

\usepackage{listings}

\lstMakeShortInline{|}

\begin{document}

This document acts as a manual for the BlueJ data collection project,
``Blackbox''.  It is intended to explain, in detail, the schema of the
collected data, and how the data relates to the BlueJ IDE.  It assumes a basic
familiarity with BlueJ's capabilities, such as the debugger, codepad, object
bench and so on.

\chapter{Concepts}

There are several concepts involved in the Blackbox project, and it is
very important when doing analysis on the data to understand the concepts
involved, and particularly the limitations of the data collection.  If you
naively assume that one virtual user is one real person, you may draw false
conclusions from your analysis.

\section{Users}

BlueJ stores its properties file in a per-user location.  For example, on
Linux, it uses |~/.bluej/bluej.properties|, on Windows 7 it is (on a typical
home installation) |C:\Users\Joe\bluej\bluej.properties|.

This properties file is the only mechanism that BlueJ has to have any sense of
identity.  If two physical people use the same account, they will appear to
BlueJ as a single user (this is still quite common on home Windows systems).
If someone uses BlueJ on a university machine, and on a laptop, and on a home
machine, they will appear to be three users.
If the computer is set up to not maintain a user's profile correctly (e.g. a
school system which wipes a user's profile on logout -- we know some systems
do this!), they will get a new profile each time they load BlueJ, and thus
will always appear to be a new user.

The user's unique identifier or opt-out preference is stored in this
properties file.  Thus the concept of a ``user'' is tied to the properties
file.  It is important to understand this when reasoning about users.

\section{Projects}

BlueJ deals with projects.  A project is a directory with a BlueJ project
file, and source files (and class files, and maybe a README, and whatever else
the user stores in the directory).  In Blackbox terms, projects are associated
with particular user ids.  They are identified only by the associated user,
and their full path (hashed, for anonymity).

If a user makes a copy of a project and opens it, it will appear to be an
entirely separate project (though you could post-process the data to see that
the project has the same source code as another of the user's projects).  If a
user has the project on a USB memory stick, and it gets assigned a different
drive letter next time they plug the stick in, the project will appear to be
different.  If a person loads the project from two different machines, even if
the project has the same path on both machines, they will appear as separate
projects belonging to separate users.

\section{Packages}

A project will have at least one package (the unnamed, default Java package),
and potentially many.  BlueJ displays a main interface window for each package
that the user opens within the project.  Thus there can be as many codepads as
there are packages in the project.  Some BlueJ features are per-package (codepad,
object bench), while others are per-project (debugger, version control).

\section{Sessions}
\label{def:sequence_id}

Each time that BlueJ is opened, we deem the time from the opening to the
closing to be ``a session''.  Each time BlueJ is loaded, the client generates
a unique session identifier to label all events from that session with.

If a user loads many projects at once in a single instance of BlueJ, these
will all count as one session.  If a user loads BlueJ twice in parallel
(e.g. by clicking the shortcut too many times), both sessions will be
recorded.  But for this reason, it is usually a good idea to use sessions to
process events, rather than solely relying on event timestamps (which will
interleave events from the two sessions).  If a user accidentally closes BlueJ
and immediately re-opens it, that will count as two sessions (though you could
spot this using the timestamps on the events in post-processing).

\section{Institutions}
\label{def:institution_id}

TODO

\section{Events}

The BlueJ client sends a stream of events to the BlueJ server, which
acknowledges them.  Ultimately, all the information recorded on the server
came by way of these discrete events.  Things like users or sessions are
reconstructed from the individual events that have been sent.  Every event
that the server receives, bar none, is recorded with an entry in the master
events table (see \autoref{tab:master_events}).

\section{Interrupted Connections}
\label{def:interruption}

There are potential problems with missing events or entire sessions in the
event stream for a user.  You should
never assume you have a user's complete history of interaction with BlueJ.
Notably, entire sessions might be missing due to users using BlueJ without an
internet connection (e.g. on an aeroplane).  Similarly, you should not assume
that you can see all interactions with a project -- source code could be
edited outside BlueJ, but even within BlueJ sessions might be missing.

Within a session, you can assume that you have all events, sequentially
consistent, from the first \texttt{bluej\_start} event, up until the last
event that is recorded in the session.  This may not be the actual final event
that the user performed in their real session -- the user's
internet connection may drop, or BlueJ may crash or get killed before a batch of events
is sent, and so on.  But there will never be a ``hole'' in the middle of a
session where events are lost, then resumed again.  Any event that fails to
send will cause the BlueJ client to stop sending for the rest of the session
-- each event is only sent once the event before it in the session has succeeded.

\section{Spam}
\label{def:spam}

The BlueJ data collection project server is an open web server to which anyone
can submit, and the BlueJ client is an open-source program.  There is no
technical way to guarantee that the data coming in is from an unmodified BlueJ
client -- it could be modified, or it could simply be made-up spam data being
submitted.  It remains to be seen whether this will be an issue.

\section{Source Code Consistency}

TODO talk about edits being captured, but a project-open event may well be a
huge edit, if project has been modified elsewhere

\section{The Debug VM}

BlueJ has two virtual machines.  One, generally known as the server VM,
handles:

\begin{itemize}
\item The graphical interface
\item Code editing
\item Compilation
\end{itemize}

No user code is ever run on the server VM.  All user code is run on a second
VM, known as the client VM or the debug VM.  (There is only ever one debug VM
at a time, for each project.)  So things like:

\begin{itemize}
\item Object construction
\item Method invocations
\item Codepad use
\item JUnit tests
\end{itemize}

Are all run on the debug VM.  When the debugger is used, the interface and
control code are in the server VM, using hooks into the debug VM to do
stepping and so on.  Whenever user code is executed, it is possible that the
result is that the debug VM terminates, but this does not mean that BlueJ has
exited.  User code that runs forever will not interrupt BlueJ, but will
prevent further use of the debug VM.

\chapter{Master Events}
\label{tab:master_events}

%schema:master_events

The master events table is the place where all events are entered.  There are
lots of different types of events that can be received, each with a variety of
different data, but all of them get one entry in the \texttt{master\_event}
table, with links to other tables where necessary.

Each master event has a user ID and almost all have a project ID (the two
exceptions being \texttt{bluej\_start} and \texttt{bluej\_finish} events) -- the
\texttt{user\_id} and \texttt{project\_id} are foreign keys for the
\texttt{users} and \texttt{projects} tables respectively.  Similarly, if
present, the \texttt{institution\_id} field is a foregin key for the
\texttt{insitutions} table.

The \texttt{created\_at} field is a server-side, trustworthy datestamp of when
the event was received.  The \texttt{source\_time} is the client-side time,
which is likely (but not guaranteed) to be sequentially consistent, but should
not be trusted to be accurate.

The \texttt{event\_id} and \texttt{event\_type} fields describe a link to
another table.  The \texttt{event\_type} field will be a capitalised
camel-cased singular version of the table name, and the \texttt{event\_id} field will
be a foreign key in that table.  So, for example, if \texttt{event\_type} is
\texttt{"CompileEvent"}, then \texttt{event\_id} will match the appropriate
\texttt{id} in the \texttt{compile\_events} table\footnote{This is how Ruby on
  Rails stores polymorphic association, it's a little quirky but not too
  horrific.}.

The \texttt{event\_name} column stores the name of the event -- each event is
detailed in the following subsections.

All events will have a \texttt{user\_id}, an \texttt{event\_name}, a
\texttt{created\_at}, a \texttt{source\_time},
and an optional
\texttt{institution\_id}.  Unless specified otherwise, they will also have a \texttt{project\_id}.

\section{Start/Finish Events}

\subsection{\lstinline|bluej_start| and \lstinline|bluej_finish|}

These two events have no extra accompanying event.  They have no
|project_id| and no |package_id|.  However, the |bluej_start| event may have
attached entries in the |extensions| table -- these are extensions loaded from
the system directories.

\section{Project Events}

\subsection{\lstinline|project_opening|}

This event will update the list of source files contained in a project, by
adding to the \texttt{source\_files} table.  This data is not stored with the
event (because it is a subset of the source histories).

The event will have an attached \hyperref[tab:source_histories]{collection of
  source histories}, representing the state of the files as the project is
opened (as a complete snapshot, not any kind of diff).  The event may have
entries in the |extensions| table, which represent extensions loaded from this
project's directory.

\subsection{\lstinline|project_closing|}

This event will no attached data (though it will have a \texttt{project\_id}).

\section{Misc}

\subsection{\texttt{resetting\_vm}}

This event will no attached data (though it will have a
\texttt{project\_id}).  It occurs when the VM is resetting, triggered either
by an explicit user request, or by a BlueJ extension.

\subsection{\texttt{compile}}

This event will link to an entry in the \texttt{compile\_events} table, which
in turn will be linked to by many entries in the \texttt{compile\_outputs}
table.  It occurs every time user source code is compiled.

\subsection{\texttt{multi\_line\_edit}}

This event is the central editing event in BlueJ.  These events are recorded
when multiple lines are edited, or a single line has been edited but the caret
has now left that line.  There is no guarantee as to how edits are grouped
together into a single edit event, but an edit event will never span a
compiler event (i.e. all edits will be flushed before a compiler).

A multi line edit will have exactly associated entry in the
\texttt{source\_histories} table.

\section{Debugger Events}

%schema:debugger_events

\subsection{\lstinline|debugger_open| and \lstinline|debugger_close|}

These events occur when the debugger window is opened or closed.  No further
data is attached.

\subsection{\lstinline|debugger_terminate|}

This event occurs when the user clicks the Terminate button in the debugger.
It kills the current debug VM, and thus all currently-executing user code.  No
further data is attached.

\subsection{\lstinline|debugger_continue|}

This event occurs when the user clicks the Continue button in the debugger.
It makes the selected thread continue execution (until Halt is clicked, or a
breakpoint is hit).  An accompanying entry in the |debugger_events| table will
have the |thread_name|, but no source location.

\subsection{\lstinline|debugger_hit_breakpoint|,
  \lstinline|debugger_stepinto|, \lstinline|debugger_stepover| and
  \lstinline|debugger_halt|}

These events occur when the user code in a thread becomes suspended.  The
|debugger_hit_breakpoint| event indicates that the suspension was due to
hitting a breakpoint, while |debugger_stepinto| and |debugger_stepover|
indicate that the thread has just completed a step request.  (If a step
request ends on a breakpoint, only the breakpoint is reported.)  The
|debugger_halt| is reported in the remaining case, that the user has
clicked the Halt button in the debugger.

For |debugger_hit_breakpoint|, there will be a link to the |breakpoints|
table, which will specify a source file and a line number.  For breakpoints,
it is guaranteed that the source file will be within the project.

For the other events, the location where the execution may have halted could
be in user code, but it could also be in external code, such as user
libraries, or system libraries.  For the other three events, the link is to
the |debugger_events| table, with a |thread_name| and a |class_source_name|
and |line_number|.  Checking the class source against local source files must
be done in a post-processing step.

%TODO update this to talk about whole stack trace

\subsection{\lstinline|debugger_breakpoint_add| and
  \lstinline|debugger_breakpoint_remove|}

These events occur when a user adds/removes a breakpoint.  They have a link to
the |breakpoints| table which details the location of the breakpoint.

\section{Codepad}

%schema:codepad_events

\subsection{\lstinline|codepad_success|, \lstinline|codepad_error| and
  \lstinline|codepad_exception|}

These events occur each time that the user types something into the codepad
window and gets a response.  The success event indicates that the code
successfully compiled, and executed without throwing an exception or without
exiting the VM early.  In this case, the entry in the |codepad_events| table
will have the fields |command| and |result| filled in with the input and
output respectively.

The |codepad_error| event indicates a compiler error occurred, or that the VM
exited during execution: the
|codepad_events| table will have |command| and |error| filled in with the
input and error respectively.  The |codepad_exception| event indicates an exception occurred: the
|codepad_events| table will have |command| and |exception| filled in with the
input and exception respectively.

\section{Method Invocation}

%schema:invocations

\subsection{\lstinline|invoke_method|}

This event occurs when the user interactively (i.e. via a menu) invokes a
static method on a class or an instance method on an object on the object
bench.  Each event will have an attached entry in the |invocations| table.
The |code| field will have the
code that was generated to execute the invocation, and the |type_name| field
will have the type of the result.

In both cases, the |result| field will have the result, which will be one of:

\begin{itemize}
\item |success| -- method was invoked successfully, the |bench_object_id|
  field will link to the |bench_objects| entry (if the result was added to the
  object bench, i.e. if the method was a constructor)
\item |compile_error| -- an error occurred while compiling the generated code
  (e.g. because the user entered invalid parameters), the |compile_error|
  field will have the full message.
\item |terminated| -- the VM terminated during execution, e.g. due to a
  |System.exit| call.
\item |exception| -- an uncaught exception occurred during execution.  The
  |exception_class| field will have the class of the exception, the
  |exception_message| field will have the message, and there will be
  associated entries in the |stack_entries| table linking to this event (the
  |invocations| entry, not the |master_events| entry).
\end{itemize}

\section{Inspector}

%schema:inspectors

\subsection{\lstinline|inspector_show| and \lstinline|inspector_hide|}

Both of these events link to an entry in the |inspectors| table.

For the |inspector_show| event, there are two cases:

\begin{enumerate}
\item The inspection was on a class.  In this case, the |static_class| field
  will have the name of the class, and the other fields will be empty.
\item The inspection was on an object.  In this case, the |class_name| field
  indicates the type of the object, the |display_name| (whatever is displayed
  on the left-hand side of the title in the object inspector) will be present,
  and the |bench_object_id| will link to a |bench_object| if the inspected
  object is on the object bench (regardless of whether that was how this
  object was reached for inspection).
\end{enumerate}

In both cases, the |unique| will have some string that uniquely identifies an
inspector within the session (this is useful during collection, and is of no
use afterwards, because the record will be unique per inspector).

For the |inspector_hide| event, there will be a link back to the |inspectors|
entry that was hidden.

\chapter{Other Database Tables}

There are many database tables in the Blackbox schema.  These tables are
written to using an object framework (Ruby on Rails) with its own persistence
model.  Thus, each table has an \verb$id$ integer field which is the primary
key, even if it would make sense for a different field to be primary key.  The
\texttt{id} field is used internally for associations, but is assigned
server-side, and never bears any relation to the BlueJ client.

\section{Users}

%schema:users

The \texttt{uuid} field is the unique user identifier.  Whenever the BlueJ
client loads up and does not find a valid BlueJ profile file with an existing
UUID inside it, it generates a new UUID.  This means:

\begin{itemize}
\item if the user does not retain their profile file (e.g. their university
  does not have roaming profiles, or wipes profiles on logout), they will
  appear with a new UUID each time they load BlueJ.
\item if the same person uses BlueJ from home (or laptop, etc) and from
  university, they will appear as two separate users.
\item if two people share the same profile (e.g. a single-user home system),
  they will appear as one user.
\end{itemize}

The \texttt{created\_at} field shows the time that this user record was
created (the first time their UUID was seen), and the \texttt{last\_update} field shows the last time that data was entered for
this user.

The \texttt{last\_sequence\_id} field is the last \hyperref[def:sequence_id]{sequence identifier} seen for
this user, and similarly the \texttt{last\_institution\_id} is the last
\hyperref[def:institution_id]{institution identifier} seen for this user.


\chapter{TODO List}

\section{Answers}

\begin{itemize}
\item Should we record events when they are triggered by extensions?
  (e.g. restart VM) -- DECIDED no, very invasive, not always possible
\item Should we model a session in the database? -- YES!
\item Should we record full stack trace during debugger, not just top line? -- YES
\item Do we want to record any Terminal usage? -- YES: open, close
\item Could we do better with distinguishing different projects with same
  name, e.g. hashing the path -- YES
\item Should we hard-code submit URL, or put it in properties?  Don't want to
  allow redirection too easily. -- hardcode, like stats
\end{itemize}

\section{Tasks}

\begin{itemize}
\item Check that the UUID is generated properly for new profiles, or profile without
UUID (or invalid UUID), and is separate to phone-home UUID
\item Finish opt-in dialog, and allow later opt-in/opt-out via prefs.
\item Implement institution ID, and changing thereof in the prefs.
\item Change hyperrefs to have section number displayed (for paper printing)
  -- make new macro?
\item Should we rename multi-line edit?
\item Are edits actually flushed before compilation?
\item Look for other coalescing opportunities
\item TODO document that rename only happens on save/compile, up until then
  edits will be recorded, but will show as being on the old file.
\item Put in the actual URL for data submission (and set up black.bluej.org,
  or whatever)
\item Handle READMEs and classes without source code (e.g. in invoker?)
\item Clear out unused database objects and tables (e.g. line edits)
\item We should generate a unique session identifier, to solve problem of
  parallel sessions -- I've already written the manual as if this has been done.
\end{itemize}

Testing/deployment:

\begin{itemize}
\item Check that all source file names are sent correctly (and are not class
  names -- or at least, make sure distinction is clear)
\item Make sure multi-threading is properly supported in the debugger
\item Make sure AJAX live stream is off in production!
\item Check speed (especially loading up)
\item Add views for white, remove visibility of ip and institution?
\end{itemize}

\section{Questions}

Old:
\begin{itemize}
\item Added sessions, think they should become per-project, and maybe even per-package?
\item Should there be |project_opening| and |package_opening| events
  (basically, what about packages?)
\item What do we want from object bench and methods?  E.g. parameter values,
  return values, ``Get'' operations, Inspects
\item What do we record for JUnit -- generated code?
\item Do we want to record settings, e.g. whether scope highlighting is in
  use
\end{itemize}

New:
\begin{itemize}
\item Spurious |multi_line_edit| at end of file on first load, I think it is adding final
  line break on load-up.  Is it worth trying to suppress this?
\item Add new package, remove package actions?
\end{itemize}

\end{document}
