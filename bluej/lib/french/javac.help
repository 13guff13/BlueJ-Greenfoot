{0}; {1} and {2} are static
(Aucune aide disponible)

';' expected
Il manque un point-virgule à la fin de la ligne de code.
La ligne fautive peut être celle indiquée par l'éditeur
ou la précédente.

'(' or '[' expected
Chaque parenthèse et crochet ouvrant doit trouver son
correspondant fermant; ça ne semble pas être le cas ici.
Avez-vous des termes croisés du genre "w[x(y]z)" ?

abstract {0} {1} cannot be accessed directly
Une méthode abstraite ne peut pas être invoquée.
Vous ne pouvez invoquer que ses descendants concrets
(i.e. une sous-classe implémentant la méthode).

abstract methods cannot have a body
Vous avez déclaré une méthode abstraite ("abstract") et
vous lui avez donné un corps.  Ceci est une
contradiction.  La déclaration d'une méthode abstraite
consiste en une entête suivie d'un point-virgule.
Supprimez ou bien le mot-clé "abstract" ou bien le
corps de la méthode.

* already in use
Il y a déjà une variable (ou un paramètre)
de ce nom dans la méthode.  Utilisez un nom
différent.  Ou supprimez le nom de type qui
la précède si vous voulez ré-utiliser la
variable.

*An explicit 'this' qualifier must be used to select the desired instance.
L'instance étant ambiguë, le compilateur recommande de
spécifier 'this', c'est-à-dire l'instance courante.

anonymous class implements interface; cannot have arguments
Puisque les classes anonymes n'implémentent que des
interfaces, et puisque les interfaces n'ont pas de
constructeurs, le constructeur d'une classe anonyme
est toujours le constructeur par défaut sans arguments.

anonymous class implements interface; cannot have qualifier for new
(Aucune aide disponible)

array required, but *
La syntaxe utilisée laisse croire que vous tentez
d'accéder à un élément d'un tableau.  Or, la variable
spécifiée n'en est pas un.

as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Le mot-clé 'assert' fait maintenant partie du langage
Java et a une signification particulière.
Vous ne pouvez pas l'utiliser comme identificateur de
variable ou de méthode.
Choisissez un autre nom.

* attempting to assign weaker access privileges; was *
Vous remplacez une méthode tout en changeant le modificateur
d'accès (private, protected, public).  Vous ne pouvez
qu'élargir l'accès (e.g. de privé à public); vous ne pouvez
pas le restreindre (e.g. de public à privé).

* attempting to use incompatible return type
(Aucune aide disponible)

* before supertype constructor has been called
Lorsqu'une classe a un ancêtre (super-classe),
son constructeur devrait toujours commencer par
appeler le constructeur de l'ancêtre :
    super(...);
devrait être la première instruction de votre
constructeur (en remplaçant l'ellipse par les
paramètres appropriés, bien sûr).  Tenter
d'utiliser les membres de la super-classe sans
appeler le constructeur va causer des problèmes !

break outside switch or loop
L'instruction "break" sert à sortir d'un bloc
d'instructions, comme une instruction "switch"
ou une boucle ("for", "while" ou "do").
Vous ne pouvez pas l'utiliser dans un autre cas.
Pour sortir d'une méthode, utilisez "return".

* but with different return type
Vous tentez de combiner deux méthodes qui ont la même
signature à l'exception du type retourné.  Ceci se
produit probablement parce que votre classe implémente
deux interfaces, chacune contribuant une des deux
méthodes sus-mentionnées.  La seule solution consiste
à changer au moins une des deux interfaces en question.

cannot access *
Le fichier classe spécifié ne peut être consulté
pour la raison spécifiée.  Probablement à la suite
d'un problème avec votre système de fichiers.

cannot assign a value to final variable *
La variable que vous tentez de modifier a été déclarée
finale ("final").  Ce qui signifie que vous ne pouvez
pas changer sa valeur.  Si vous avez vraiment à changer
sa valeur, supprimez le mot-clé "final" de sa déclaration.

* cannot be accessed from outside package
La classe que vous cherchez à utiliser ici n'est pas
publique (le mot-clé "public" ne précède pas le mot-clé
"class").
Une classe non-publique ne peut être utilisée que par
les classes qui partagent son paquetage.  Si nécessaire,
changez sa définition afin de la rendre publique.

* cannot be applied to *
L'opérateur que vous utilisez ici n'est pas applicable
à ce type de valeur.  Vous utilisez soit le mauvais type
de valeur, soit le mauvais opérateur.

* cannot be dereferenced
Vous tentez d'utiliser le "." pour accéder à un champ
ou une méthode d'un objet.  Cependant, la variable utilisée
n'est pas de type objet - elle ne possède pas de champs
ni de méthodes.

* cannot be inherited with different arguments:*
(Aucune aide disponible)

*cannot be referenced from a static context
Vous tentez d'accéder à un champ ou méthode d'instance
à partir d'une méthode statique (méthode de classe).
Ceci n'est pas permis.  Les méthodes statiques ne
peuvent accéder qu'aux autres champs et méthodes
statiques de leur classe à moins d'utiliser une
instance explicite de la classe (créée par la méthode
statique).

cannot inherit from final *
La super-classe (l'ancêtre mentionné par le mot-clé
"extends") a été déclarée finale.  Ceci signifie
qu'elle n'accepte pas de sous-classes.
Désolé - vous ne pouvez pas la sous-classer sans
son consentement...

cannot read: *
(Aucune aide disponible)

cannot resolve symbol*
Vous utilisez un symbole (un nom de variable, méthode
ou classe) qui n'apparaît pas dans le contexte.
Peut-être y a-t-il une coquille dans le nom ?
Avez-vous oublié de déclarer le symbole en question ?
Apparaît-il dans un autre contexte ?  Est-il déclaré
plus tard ou dans un sous-contexte ?

cannot return a value from method whose result type is void
Un type de résultat "void" dans la signature d'une méthode
signifie qu'elle n'en retourne aucun.  Le corps de la
méthode ne doit donc pas avoir d'instruction "return".

cannot select a static class from a parameterized type
(Aucune aide disponible)

'case', 'default' or '}' expected
Le corps de votre expression "switch" semble erroné.
La syntaxe de l'instruction "switch" est :
   switch ( Expression )
   {
   case ConstantExpression :
      ...
   default :
      ...
   }

'catch' without 'try'
"catch" est un mot-clé Java qui ne peut apparaître
qu'après un bloc "try".  La syntaxe est :
   try
   {
      ...
   }
   catch(Exception e)
   {
      ...
   }

* clashes with class of same name
Assurez-vous que la classe et le paquetage
portent des noms différents.
Par convention, les noms de classes débutent
par une majuscule, les noms de paquetages
par une minuscule.

* clashes with package of same name
Assurez-vous que la classe et le paquetage
portent des noms différents.
Par convention, les noms de classes débutent
par une majuscule, les noms de paquetages
par une minuscule.

'class' or 'interface' expected
Les mots-clés "class" ou "interface" sont attendus
au début du fichier source.  Ni l'un ni l'autre
n'apparaît, ou il y a autre chose qui les précède.

'.class' expected
(Aucune aide disponible)

code too large for try statement
Il y a trop d'instructions à l'intérieur du bloc "try".
Créez une méthode distincte et appelez-la depuis le bloc.

* conflicts with a compiler-synthesized symbol in *
(Aucune aide disponible)

constant expression required
Vous avez utilisé une variable ou une expression ici,
ce qui est illégal.  Vous ne pouvez utiliser que des
constantes ici.  Une constante est un nombre (e.g. "42")
ou un identificateur déclaré "final".

continue outside of loop
L'instruction "continue" sert à passer à l'itération
suivante d'une boucle ("for", "while" ou "do").
On ne peut donc l'utiliser en dehors d'une boucle.

cyclic inheritance involving *
Vous tentez de sous-classer une classe, mais
cette dernière a déjà déclaré qu'elle sous-classait
votre sous-classe !  Deux classes ne peuvent être
des sous-classes l'une de l'autre.

* does not exist
Le nom spécifié ici (désignant une variable,
classe ou paquetage) n'existe pas.  Aucune
variable, classe ou paquetage ne porte ce nom.

* does not take parameters
Le type utilisé n'est pas paramétrisé.  Par
conséquent, vous ne pouvez spécifier de paramètre.

duplicate case label
Vous avez utilisé le même cas deux fois à l'intérieur
d'une même instruction "switch".  Chaque cas doit être
unique.

duplicate class:*
Il semble qu'il existe déjà une classe de ce nom.

duplicate default label
Vous avez utilisé le mot-clé "default" deux fois à
l'intérieur d'une même instruction "switch".
Il ne peut y avoir qu'un cas fourre-tout.

'else' without 'if'
Le mot-clé 'else' ne peut apparaître que dans une
instruction 'if', comme ceci :
   if (condition)
      instruction;
   else
      instruction;
Avez-vous oublié les accolades ?
Si l'une ou l'autre instruction du if-else est
composée, la syntaxe est :
   if (condition)
   {
      ...
   }
   else
   {
      ...
   }

empty character literal
Vous avez déclaré une constante caractère vide.
Vous ne pouvez pas utiliser ''.  Une constante
caractère doit compter un et un seul caractère,
comme par exemple 'a'.  Les caractères non-imprimables
sont représentés par un contre-oblique suivi d'un
autre caractère, comme par exemple '\n' ou '\t'.

error reading *
Une erreur est survenue lors de la lecture du fichier indiqué.
Il y a probablement un problème avec le système de fichiers
(ou avec le réseau si le fichier en question est distant).

error while writing *
Une erreur est survenue lors de l'écriture du fichier indiqué.
Il y a probablement un problème avec le système de fichiers
(ou avec le réseau si le fichier en question est distant).
Le fichier est-il protégé contre l'écriture ?  Le disque
est-il saturé ?

error writing source; cannot overwrite input file *
(Aucune aide disponible)

* expected
Le symbole sus-mentionné était attendu à cet 
endroit mais un autre symbole a été rencontré.
Essayez de comprendre pourquoi Java s'attendait
à ce symbole plutôt qu'à celui que vous avez
utilisé.

'finally' without 'try'
Le mot-clé "finally" ne peut apparaître qu'après
un bloc "try".  La syntaxe est :
   try
   {
      ...
   }
   finally
   {
      ...
   }
Un bloc "catch" peut optionnellement s'insérer entre
les blocs "try" et "finally".

floating point number too large
Le système est incapable de traiter un nombre réel
aussi grand.

floating point number too small
Le système est incapable de traiter un nombre réel
aussi petit.

* has already been caught
Cette instruction 'catch' est inutile.  Elle ne
pourra jamais s'exécuter, car les exceptions
qu'elle attrape sont déjà traitées par une
instruction 'catch' précédente.

{0} has {1} access in {2}
(Aucune aide disponible)

* has been deprecated
Vous utilisez une méthode qui n'est plus recommandée.
Il existe probablement une autre méthode (ou classe)
qui fournisse cette fonctionnalité.  Consultez la
documentation pour plus de détails.

{0} has no match in entry in {1}; required {2}
(Aucune aide disponible)

hexadecimal numbers must contain at least one hexadecimal digit
Vous avez spécifié un nombre hexadécimal (en le préfaçant
de "0X" ou "0x").  Il doit y avoir au moins un chiffre
hexadécimal après le préfixe (e.g. "0X" n'est pas légal).

illegal character:*
Il y a un caractère illégal dans le fichier source.
Ce caractère pourrait fort bien être invisible.
Si vous ne pouvez le trouver et le supprimer,
supprimez la ligne entière et ré-écrivez la.

illegal combination of modifiers: *
Vous avez tenté de combiner deux qualificatifs Java
de façon illégale.  Ils sont probablement contradictoires.
Par exemple, une méthode ne peut être à la fois "abstract"
et "native", "final", "private" ou "synchronized".

illegal escape character
Les caractères spéciaux s'écrivent à l'aide d'un
contre-oblique et d'un second caractère, comme par
exemple '\n'.  Les caractères spéciaux reconnus sont :
\b, \f, \n, \r, \t, \\, \', \"
ainsi que les nombres octaux (e.g. \0 à \377).
Les caractères Unicode (\u0000 à \uFFFF) ne peuvent
apparaître que dans des chaînes.

illegal forward reference
Vous avez tenté d'utiliser un champ avant de l'avoir
déclaré.  À la différence des méthodes, les champs ne
peuvent être utilisés dans une instruction ou
déclaration tant qu'ils n'ont pas été déclarés.

illegal initializer for *
Vous avez tenté d'initialiser une variable à l'aide
d'une expression de type incompatible.

illegal line end in character literal
Vous avez un retour à la ligne alors qu'un caractère
était attendu.  Pour inclure un retour à la ligne
("newline") dans une chaîne, utilisez '\n'.

illegal qualifier; {0} is not an inner class
Le modificateur utilisé n'est applicable qu'à une
classe imbriquée.

illegal start of expression
L'expression débute par un atome illégal.

illegal start of type
Là où un nom de type était attendu, quelque chose
d'autre (probablement un mot-clé) a été rencontré.
Assurez-vous que la définition de type soit correcte.

illegal unicode escape
La séquence n'a pas été reconnue comme étant un
caractère Unicode.  Ceux-ci sont représentés par
\u0000 à \uffff, où les quatre derniers caractères
forment un nombre hexadécimal.

improperly formed type, some parameters are missing
(Aucune aide disponible)

incomparable types: *
(Aucune aide disponible)

incompatible types*
Une expression d'un certain type est requise ici.
Vous avez utilisé une expression d'un type différent
qui n'est pas compatible (e.g. une expression
"String" alors qu'un "int" est requis).

inconvertible types*
Le type que vous avez utilisé ici ne peut pas être
automatiquement converti au type requis.

initializer must be able to complete normally
Vous ne pouvez pas lancer d'exceptions ni abréger
de toute autre manière un bloc d'initialisation,
statique ou non.

inner classes cannot have static declarations
Une classe imbriquée ne peut déclarer de
types statiques.  Si vous avez besoin d'un
type statique ici, déclarez-le dans la classe
englobante.

integer number too large: *
Vous avez spécifié un nombre trop grand pour le type
entier attendu.  Vous devriez utiliser un type plus
grand (par exemple "long" au lieu de "int").

interface expected here
Le nom apparaissant après le mot-clé "extends" ne désigne
pas une interface.  Une interface ne peut sous-classer
qu'une autre interface.

interface methods cannot have body
Les méthodes d'interfaces ne peuvent être que
déclarées - il ne peut y avoir de corps.
Par conséquent, la signature de méthode ne peut
être suivie que d'un point-virgule.

internal error; cannot instantiate *
Une erreur interne est survenue pendant
l'instanciation de la classe indiquée.
(Erreur générique)

invalid method declaration; return type required
Une déclaration de méthode doit spécifier le type retourné.
Par exemple, si votre méthode retourne un String :
   public String maMéthode();
Si vous ne voulez pas que la méthode retourne de valeur,
utilisez le mot-clé "void" :
   public void maMéthode();

* is abstract; cannot be instantiated
La classe est abstraite ("abstract").  Ce qui signifie
qu'elle comprend une ou plusieurs méthodes dont
l'implémentation n'est pas fournie (des "méthodes
abstraites").  Vous ne pouvez pas créer d'objets
abstraits.  Trouvez (ou créez) une classe descendante
qui implémente les méthodes abstraites.  Vous pourrez
alors créer des objets de cette classe.

* is accessed from within inner class; needs to be declared final
Les variables locales ne sont normalement pas
accessibles aux classes imbriquées.  Vous devrez
soit supprimer les références apparaissant dans la
classe imbriquée, soit déclarer la variable "final"
(ce qui la rendra accessible car constante).

* is already defined in *
Il existe déjà une variable (ou un paramètre)
dans cette méthode qui porte le même nom.
Choisissez un nom différent.  Cherchiez-vous
à utiliser la même variable ?  Dans ce cas,
supprimez le nom de type afin de ne pas
déclarer la variable une seconde fois.

* is already defined in this compilation unit
Vous avez utilisé ce nom deux fois ici.
Choisissez un nom différent pour cet identificateur.

{0} is already defined in a single-type import
(Aucune aide disponible)

* is ambiguous, both *
L'identificateur mentionné est ambigu car il y a plus d'une
classe ou interface de ce nom parmi les paquetages que vous
avez importés.
Vous devez fournir le chemin d'accès de la classe lors de
son invocation (e.g. java.util.List) ou de son importation
(e.g. import java.util.List).

* is never thrown in body of corresponding try statement
Vous avez déclaré vouloir attraper une exception ici.
Mais il est certain que cette exception ne sera jamais
levée !  Aucune des instructions du bloc "try" ne peut
lever cette exception.

* is not abstract and does not override abstract method *
Votre classe, qui n'est pas abstraite,
déclare une méthode qui l'est.

* is not an inner class
La classe spécifiée n'est pas imbriquée dans (n'est
pas contenue dans) la classe courante.

* is not defined in a public class or interface; cannot be accessed from outside package
L'identificateur indiqué n'est déclaré ni par une classe
publique ni par une interface; par conséquent il ne peut
être invoqué en dehors du paquetage où il apparaît.

* is public, should be declared in a file named *
Chaque classe publique doit avoir son texte source dans un
fichier du même nom portant l'extension ".java".
Par exemple, la "public class Foo" doit avoir son
texte source dans le fichier "Foo.java".

* is reserved for internal use
Le terme indiqué est réservé à des fins internes.
Vous devrez changer le nom de votre variable ou classe.

malformed floating point literal
Vous avez commis une erreur de syntaxe en tentant
d'écrire un nombre réel.  Quelques exemples corrects :
18.   18.1   18.e12   1.8f   .18   .2E2d   18e81   18d

* might already have been assigned to
Une variable finale ne peut accepter une valeur qu'une seule
fois.  La variable en question est finale et le compilateur
croit qu'il est possible que les deux instructions soient
exécutées.

* might not have been initialized
Vous utilisez une variable locale sans avoir la
certitude qu'elle ait été initialisée.  Dans le
doute, initialisez-la lors de sa déclaration.

missing method body, or declare abstract
Les méthodes doivent soit comprendre un corps, soit
être déclarées abstraites.  Le corps est un bloc
d'instructions encadré d'accolades {} qui suit
la signature.  Exemples :
   public abstract int getAnswer();
   public int getAnswer() {};

missing return statement
Une valeur est attendue de cette méthode.  Or, il n'y a
aucune instruction "return" dans son corps.
Vous devez soit changer le type retourné par la méthode
en "void", soit ajouter l'instruction "return" manquante.

missing return value
L'instruction "return" n'a pas d'argument, alors qu'on
en attendait un.  Vous devez soit changer le type retourné
par la méthode en "void", soit ajouter l'argument manquant
à l'instruction "return".

* must be caught or declared to be thrown
Votre code invoque une méthode qui pourrait lancer
une exception.  Vous devez soit attraper l'exception,
soit déclarer que votre méthode la laisse s'échapper.
Pour attraper l'exception, utilisez un bloc "try" :
   try 
   {
      ...
   }
   catch(Exception e)
   {
      ...
   }
Pour la laisser s'échapper, ajoutez :
   throws <ExceptionName>
à la signature de votre méthode.

* must be first statement in constructor
Lorsqu'une classe a un ancêtre (super-classe),
son constructeur devrait toujours commencer par
appeler le constructeur de l'ancêtre :
    super(...);
devrait être la première instruction de votre
constructeur (en remplaçant l'ellipse par les
paramètres appropriés, bien sûr).  Tenter
d'utiliser les membres de la super-classe sans
appeler le constructeur va causer des problèmes !

name clash: *
Vous avez défini deux méthodes portant le même nom.
Ceci n'est possible que si l'une remplace l'autre (ce
qui n'est pas le cas ici).  Changez l'un des noms.

native methods cannot have a body
Vous avez déclaré une méthode intrinsèque (mot-clé
"native") et lui avez donné un corps.  Or, les méthodes
intrinsèques n'ont qu'une signature suivie d'un
point-virgule.  Supprimez soit la mot-clé "native",
soit le corps de la méthode.

no enclosing instance of type {0} is in scope
(Aucune aide disponible)

no interface expected here
Vous faites une référence inattendue à une interface
(possiblement avec la déclaration "extends" d'une classe).
Une classe ne peut sous-classer qu'une classe, pas une
interface.  Si vous désirez implémenter cette interface,
utilisez plutôt le mot-clé "implements".

not a loop label: *
Les étiquettes utilisées comme argument d'une
instruction "continue" doivent identifier une
instruction de boucle ("while", "do" ou "for").
L'étiquette spécifiée ici n'identifie pas une boucle.

not a statement
La ligne de code en question n'est pas
une instruction complète.

* not allowed here
Vous avez utilisé un modificateur d'accès (tel que
"private", "protected", etc.) qui n'est pas permis
en cet endroit.

not an enclosing class:*
Vous avez tenté d'accéder à l'objet courant ('this') d'une
classe extérieure à la vôtre.  Ceci n'est possible que si
la classe extérieure englobe la vôtre.

orphaned *
(Aucune aide disponible)

* overridden method does not throw *
Vous remplacez une méthode et levez une nouvelle
exception.  Une méthode remplaçante ne peut pas
introduire de nouvelles exceptions; elle peut en
lever moins, mais pas plus.

{0}; overridden method is {1}
(Aucune aide disponible)

possible fall-through into case
Il se pourrait que l'exécution d'une clause "case"
d'une instruction "switch" se poursuive à la clause
suivante.  Si ce n'est pas ce que vous désirez,
concluez la clause fautive par une instruction "break"
ou l'équivalent.

possible loss of precision
La conversion indiquée pourrait causer une perte
de précision numérique.

qualified new of static class
(Aucune aide disponible)

recursive constructor invocation
Votre code fait en sorte que le constructeur
s'invoque lui-même.  Ce n'est pas permis car
car cela entraînerait presque certainement
une boucle infinie.

repeated interface
Vous avez mentionné une interface plus d'une
fois dans la déclaration "implements".
Une fois suffit !

repeated modifier
Vous avez mentionné un modificateur (e.g.
final, static, public, private, volatile) plus
d'une fois dans la déclaration.  Une fois suffit !

return outside method
Vous ne pouvez utiliser l'instruction 'return'
que dans une méthode - pas dans un bloc
d'initialisation ou tout autre segment de code.

* should be declared abstract; it does not define *
Cette classe descend d'une classe abstraite ou hérite
d'une interface abstraite.  Les classes et interfaces
abstraites définissent des méthodes sans en fournir
l'implémentation.  Cette classe ne fournit pas les
implémentations manquantes, ce qui fait qu'elle est
encore abstraite.
Vous devez soit déclarer la classe abstraite :
   public abstract class ...
soit fournir l'implémentation manquante mentionnée
dans le message d'erreur.

signature does not match {0}; incompatible interfaces
Parce que les signatures sont différentes, ces
interfaces sont mutuellement incompatibles.

signature does not match {0}; incompatible supertype
(Aucune aide disponible)

'try' without 'catch' or 'finally'
Si vous utilisez un bloc "try", il doit être immédiatement
suivi soit par un bloc "catch", soit par un bloc "finally"
(ou les deux).  La syntaxe est :
   try
   {
      ...
   }
   catch(Exception e)
   {
      ...
   }
   finally
   {
      ...
   }

type parameter {0} is not within its bound *
(Aucune aide disponible)

type parameters of {0} cannot be determined
(Aucune aide disponible)

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
(Aucune aide disponible)

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
(Aucune aide disponible)

type variables cannot be dereferenced
Vous ne pouvez pas utiliser le "." pour tenter
d'accéder aux champs ou méthodes membres d'une
variable-type.

unclosed character literal
Il semble que vous ayez écrit une constante caractère sans
inclure l'apostrophe fermante : 'a au lieu de 'a'.

unclosed comment
Un commentaire qui débute par /* ou /** doit
éventuellement être fermé par */.

unclosed string literal
Il semble que vous ayez écrit une chaîne de caractères
sans inclure le guillemet anglais fermant : «"une chaîne»
au lieu de «"une chaîne"».  La chaîne doit être écrite
sur une seule ligne.

undefined label: *
L'étiquette que vous tentez d'utiliser ici est
introuvable.  Soit qu'elle n'existe pas, soit
qu'elle ne soit pas dans le contexte.
Assurez-vous qu'il n'y ait pas de coquille
(les étiquettes sont sensibles à la casse).
Le second cas peut se produire lorsque l'étiquette
est dans un bloc (délimité par les accolades) -
règle générale, une étiquette n'existe que dans le
contexte du bloc qui la définit.

unexpected type
Une expression d'un certain type est requise ici.
Vous avez utilisé une expression d'un type différent
qui n'est pas compatible (e.g. une expression
"String" alors qu'un "int" est requis).

unreachable statement
Cette instruction ne sera jamais exécutée.
Si vous examinez le code attentivement, vous
remarquerez que l'instruction ne peut être
atteinte en aucun cas.  Supprimez-la ou
corrigez votre logique.

* uses or overrides a deprecated API.
Vous utilisez ou remplacez une méthode qui n'est plus
recommandée.  Il existe probablement une autre méthode
(ou classe) qui fournisse cette fonctionnalité.
Consultez la documentation pour plus de détails.

variable {0} might be assigned in loop
La variable finale en question était certainement sans
valeur avant la boucle, et pourrait s'en voir assigner
une dans la boucle, peut-être plus d'une fois - ce
qui n'est pas acceptable.

'void' type not allowed here
Le type "void" ne peut être utilisé dans ce contexte.
Il ne sert qu'à déclarer qu'une méthode ne retourne pas
de résultat; il ne peut y avoir de variables de ce type.

wrong number of type arguments; required *
(Aucune aide disponible)
