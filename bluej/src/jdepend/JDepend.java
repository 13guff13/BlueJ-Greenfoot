package jdepend;

import java.io.File;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;

import sun.tools.javac.SourceClass;
import sun.tools.javac.BatchEnvironment;
import sun.tools.java.*;
import sun.tools.javac.JDependJavacMain;
import sun.tools.javac.JDependJavacWatcher;

/**
 ** JDepend: generate Makefile dependencies from Java sources
 ** $Id: JDepend.java 36 1999-04-27 04:04:54Z mik $
 **/
 
public class JDepend implements JDependJavacWatcher
{
	Hashtable classes = new Hashtable();
	
	public static void main(String[] args)
	{
		JDepend depend = new JDepend();
		
		if(args.length == 0)
		{
			System.err.println("jdepend file.java ...");
			System.exit(-1);
		}
		
		for(int i = 0; i < args.length; i++)
		{
			// parse args
			if(args[i].equals("-d") && (i + 1 < args.length))
				ClassTarget.classdir = args[++i];
		}

		JDependJavacMain javac = new JDependJavacMain(System.err);
		boolean success = javac.compile(args, depend);
		depend.writeMakefile(System.out);
		System.exit(success ? 0 : 1);
	}
	
	protected static void printWarning(String msg)
	{
		System.err.println(msg);
	}
	
	public void writeMakefile(PrintStream out)
	{
		// Resolve all dependencies
		for(Enumeration e = classes.elements(); e.hasMoreElements(); )
		{
			ClassTarget c = (ClassTarget)e.nextElement();
			c.resolveDependencies(classes);
		}
		
		// Write Makefile header
		out.println("# This Makefile was automatically generated by JDepend");
		out.println("# JDepend was written by Michael Cahill (mjc@softway.com.au)");
		// out.println("# See http://www.spin.net.au/~mjc/jdepend for more info");
		
		// Traverse graph finding compilation jobs
		Vector jobs = new Vector();
		
		for(Enumeration e = classes.elements(); e.hasMoreElements(); )
		{
			ClassTarget c = (ClassTarget)e.nextElement();
			search(c, new Stack(), jobs);
		}
		
		for(Enumeration e = jobs.elements(); e.hasMoreElements(); )
		{
			Job job = (Job)e.nextElement();
			job.writeRule(out);
		}
	}
	
	int id = 0;
	protected void search(ClassTarget t, Stack stack, Vector jobs)
	{
		if(t.id > 0)
			return;
		
		t.id = t.min_id = ++id;
		stack.push(t);
		
		for(Enumeration e = t.getDependencies(); e.hasMoreElements(); )
		{
			ClassTarget to = (ClassTarget)e.nextElement();
			
			if(to.id == 0)
				search(to, stack, jobs);
				
			if(stack.search(to) != -1)
				t.min_id = Math.min(t.min_id, to.min_id);
		}
			
		if(t.id == t.min_id)
		{
			Job job = new Job();
			
			// Create a "job"
			for(ClassTarget c = null; c != t; )
			{
				c = (ClassTarget)stack.pop();
				job.addClass(c);
			}
			
			jobs.addElement(job);
	}
		}

	public void notifyParsed(ClassDeclaration decl, SourceClass src, BatchEnvironment env)
	{
		// not interested
	}
	
	public void notifyCompiled(SourceClass src, BatchEnvironment env)
	{
		String srcName = src.getName().toString();
		String srcFileName = ((ClassFile)src.getSource()).getPath();
		ClassTarget srcTarget = (ClassTarget)classes.get(srcFileName);
		
		if(srcTarget == null)	// new Target - normal case
		{
			srcTarget = new ClassTarget(srcName, srcFileName);
			classes.put(srcFileName, srcTarget);
		}
		
		for(Enumeration e = JDependJavacMain.getDependencies(src); e.hasMoreElements(); )
		{
			ClassDeclaration to = (ClassDeclaration)e.nextElement();
			Object toSrc = to.getClassDefinition().getSource();
			
			if(toSrc instanceof ClassFile)
			{
				String toName = ((ClassFile)toSrc).getPath();
				srcTarget.addDependency(toName);
			}
		}
	}
}
